generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  Int       @id @default(autoincrement())
  supabaseId          String?   @unique
  email               String    @unique
  passwordHash        String?
  name                String?
  phone               String?
  country             String?
  profilePhoto        String?   // URL or base64 of profile photo
  
  // Exchange credentials (encrypted) - legacy, use ExchangeConnection instead
  binanceApiKeyEnc    String?
  binanceApiSecretEnc String?
  binanceConnectedAt  DateTime?
  
  emailVerified       Boolean   @default(false)
  emailVerifyToken    String?
  createdAt           DateTime  @default(now())
  googleId            String?   @unique
  
  // Subscription
  subscriptionPlan    String?
  subscriptionStatus  String?
  subscriptionExpires DateTime?
  
  // Notification preferences
  telegramId          String?
  telegramEnabled     Boolean   @default(false)
  emailNotifications  Boolean   @default(true)
  notifyOnTrade       Boolean   @default(true)
  notifyOnBacktest    Boolean   @default(true)
  notifyOnBalance     Boolean   @default(true)
  
  // XP and achievements
  xp                  Int       @default(0)
  level               Int       @default(1)
  achievements        String?   // JSON array of unlocked achievements
  
  // Relations
  strategies          Strategy[]
  strategyRuns        StrategyRun[]
  trades              Trade[]
  backtestResults     BacktestResult[]
  exchangeConnections ExchangeConnection[]
  backtestQueue       BacktestQueue[]
}

model ExchangeConnection {
  id          Int       @id @default(autoincrement())
  exchange    String    // binance, bybit, okx
  apiKeyEnc   String    // Encrypted API key
  secretEnc   String    // Encrypted secret
  passwordEnc String?   // Encrypted passphrase (for OKX)
  testnet     Boolean   @default(true)
  isActive    Boolean   @default(true)
  connectedAt DateTime  @default(now())
  lastUsedAt  DateTime?
  
  userId      Int
  user        User      @relation(fields: [userId], references: [id])
  
  @@unique([userId, exchange])
}

model Strategy {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  category    String?
  config      String
  pairs       String
  maxDeals    Int      @default(5)
  orderSize   Float    @default(1000)
  
  lastBacktestProfit    Float?
  lastBacktestDrawdown  Float?
  lastBacktestSharpe    Float?
  lastBacktestWinRate   Float?
  
  isPublic    Boolean  @default(false)
  isActive    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  userId      Int
  user        User     @relation(fields: [userId], references: [id])
  runs        StrategyRun[]
  backtests   BacktestResult[]
}

model StrategyRun {
  id          Int       @id @default(autoincrement())
  config      String
  pairs       String
  exchange    String    @default("binance")
  status      String    @default("running")
  startedAt   DateTime  @default(now())
  stoppedAt   DateTime?
  
  initialBalance  Float
  currentBalance  Float?
  totalProfit     Float?
  totalTrades     Int     @default(0)
  winningTrades   Int     @default(0)
  maxDrawdown     Float?
  
  lastError   String?
  errorCount  Int       @default(0)
  
  userId      Int
  user        User      @relation(fields: [userId], references: [id])
  strategyId  Int
  strategy    Strategy  @relation(fields: [strategyId], references: [id])
  trades      Trade[]
}

model Trade {
  id            Int      @id @default(autoincrement())
  symbol        String
  side          String
  type          String   @default("market")
  quantity      Float
  price         Float
  amount        Float
  fee           Float?
  
  entryPrice    Float?
  exitPrice     Float?
  profitLoss    Float?
  profitPercent Float?
  
  status        String   @default("pending")
  orderId       String?
  comment       String?
  marketState   String?
  createdAt     DateTime @default(now())
  executedAt    DateTime?
  
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  strategyRunId Int?
  strategyRun   StrategyRun? @relation(fields: [strategyRunId], references: [id])
}

model BacktestResult {
  id          Int      @id @default(autoincrement())
  name        String
  config      String
  pairs       String
  startDate   DateTime
  endDate     DateTime
  initialBalance Float
  
  netProfit       Float
  netProfitUsd    Float
  maxDrawdown     Float
  sharpeRatio     Float
  sortinoRatio    Float
  winRate         Float
  totalTrades     Int
  profitFactor    Float
  yearlyReturn    Float
  
  chartData   String?
  trades      String?
  
  createdAt   DateTime @default(now())
  
  userId      Int
  user        User     @relation(fields: [userId], references: [id])
  strategyId  Int?
  strategy    Strategy? @relation(fields: [strategyId], references: [id])
}

model Comment {
  id        Int      @id @default(autoincrement())
  author    String?
  text      String
  photo     String?
  createdAt DateTime @default(now())
}

model RefundRequest {
  id          Int       @id @default(autoincrement())
  userId      Int
  email       String
  reason      String
  amount      Float
  status      String    @default("pending") // pending, approved, rejected, completed
  paymentId   String?
  adminNotes  String?
  createdAt   DateTime  @default(now())
  processedAt DateTime?
}

// Backtest queue for managing sequential backtest execution
model BacktestQueue {
  id              Int       @id @default(autoincrement())
  userId          Int
  user            User      @relation(fields: [userId], references: [id])
  
  // Backtest configuration
  strategyName    String
  payload         String    // JSON payload for backtest
  
  // Queue status
  status          String    @default("queued")  // queued, processing, completed, failed
  queuePosition   Int?
  progress        Int       @default(0)  // 0-100%
  estimatedSeconds Int?     // Estimated duration in seconds
  
  // Notification preferences
  notifyVia       String    // "telegram", "email", or "both"
  notifyEmail     String?
  notifyTelegram  String?
  
  // Results
  resultId        Int?      // Link to BacktestResult when complete
  errorMessage    String?
  
  // Timestamps
  createdAt       DateTime  @default(now())
  startedAt       DateTime?
  completedAt     DateTime?
  
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}
